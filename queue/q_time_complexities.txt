Time Complexity per Operation

Checking if the queue is empty:
- O(1), his checks if both the front and rear lists are empty using pattern matching or basic list inspection.

Adding an element (enqueue):
- O(1), The element is added to the front of the rear list, which is a constant-time operation in singly linked lists.

Removing an element (dequeue):
- O(1) in the common case, when the front list is not empty.

- O(n) in the worst case, when the front list is empty and the rear list must be reversed to restore the queue.

- Amortized O(1) overall, since the cost of reversing the rear is spread over multiple operations.

Accessing the first element (head):
- O(1) â€” The front of the queue is always available at the head of the front list or, in fallback cases, the last of the rear list (which is O(n), but this is rare and only happens if the front is empty).

Accessing the last element (tail):
- O(1) if the rear list is non-empty (its head is the last element).

- O(n) if the rear is empty and the last element must be retrieved from the end of the front list.

- In general, this is O(n) in the worst case, but O(1) in most practical scenarios where elements are being enqueued frequently.

Testing if this kind of answer works so we can memorize on the simplest answers, it worked once:
Check if empty - O(1) 
Add an element - O(1) 
Removing/dequeue an element - Amortized O(1) 
Retrieve head - O(1) 
Getting the tail - O(1)

** Function definitions **
Empty? - Checks if the queue has no elements in either the front or rear list 
Enqueue - Adds a new item to the rear of the list to prepare it for future removal in order. 
Dequeue - Removes the item at the very front of the list, if the front list becomes empty, it reverses the rear list and moves it to the front. 
Head - Returns the first item in the queue without removing it, using the front list if available. 
Tail - Returns the last item in the queue without removing it, using the rear list if it has elements, otherwise checking the end of the font list. 
To_List - Combines the front list and reversed rear list into a single ordered list of all items in the queue 
From_list - Takes a standard list of items and creates a queue with all items placed in the front of the list.

** Structuring Question: **
Can you describe how a queue is represented in terms of its structure? Be sure to use only words, not symbols or code-like notation.

Yes, a queue is made up of two lists - a front and a rear. The front list is ordered properly from items that entered queue first, and includes the "head" of the list at the very front. It is the item that is next to be dequeue'd. The rear list is ordered in reverse, to allow for quick enqueu'ing - as the enqueue operation will add the another item to the very end of the queue. 